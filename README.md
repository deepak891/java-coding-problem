# java-coding-problem

Java Problems
===============
String numbers and Math
1 Counting duplicate characters: Write a program that counts duplicate characters from a given string
 

2 Finding the first non-repeated character: Write a program that returns the first non-repeated character from a given string
 

3 Reversing letters and words: Write a program that reverses the letters of each word and a program that reverses the letters of each word and the words themselves
 

4 Checking whether a string contains only digits: Write a program that checks whether the given string contains only digits
 

5 Counting vowels and consonants: Write a program that counts the number of vowels and consonants in a given string. Do this for the English language, which has five vowels (a, e, i, o, and u)
 

6 Counting occurrences of a certain character: Write a program that counts the occurrences of a certain character in a given string
 

7 Converting String into int, long, float, or double: Write a program that converts the given String object (representing a number) into int, long, float, or double
 

8 Moving white spaces from a string: Write a program that removes all white spaces from the given string
 

9. Joining multiple strings with a delimiter: Write a program that joins the given strings by the given delimiter
 

10. Generating all permutations: Write a program that generates all of the permutations of a given string
 

11. Checking whether a string is a palindrome: Write a program that determines whether the given string is a palindrome or not
 

12. Removing duplicate characters: Write a program that removes the duplicate characters from the given string
 

13. Removing given characters: Write a program that removes the given character from the given string
 

14. Finding the character with the most appearances: Write a program that finds the character with the most appearances in the given string
 

15. Sorting an array of strings by length: Write a program that sorts by the length of the given array of strings
 

16. Checking that a string contains a substring: Write a program that checks whether the given string contains the given substring
 

17. Counting substring occurrences a string: Write a program that counts the occurrences of a given string in another given string
 

18. Checking whether two strings are anagrams: Write a program that checks whether two strings are anagrams. Consider that an anagram of a string is a permutation of this string by ignoring capitalization and white spaces
 

19. Declaring multiline strings (text blocks): Write a program that declares multiline strings or text blocks
 

20. Concatenating the same string n times: Write a program that concatenates the same string a given number of times
 

21. Removing leading and trailing spaces: Write a program that removes the leading and trailing spaces of the given string
 

22. Finding the longest common prefix: Write a program that finds the longest common prefix of given strings
 

23. Applying indentation: Write several snippets of code to apply indentation to the given text
 

24. Transforming strings: Write several snippets of code to transform a string into another string
 

25. Computing the minimum and maximum of two numbers: Write a program that returns the minimum and maximum of two numbers
 

26. Summing two large int/long numbers and operation overflow: Write a program that sums two large int/long numbers and throws an arithmetic exception in the case of an operation overflow
 

27. String as an unsigned number in the radix: Write a program that parses the given string into an unsigned number (int or long) in the given radix
 

28. Converting into a number by an unsigned conversion: Write a program that converts a given int number into long by an unsigned conversion
 

29. Comparing two unsigned numbers: Write a program that compares the given two numbers as unsigned
 

30. Division and modulo of unsigned values: Write a program that computes the division and modulo of the given unsigned value
 

31. double/float is a finite floating-point value: Write a program that determines whether the given double/float value is a finite floating-point value
 

32. Applying logical AND/OR/XOR to two boolean expressions: Write a program that applies the logical AND/OR/XOR to two boolean expressions
 

33. Converting BigInteger into a primitive type: Write a program that extracts the primitive type value from the given BigInteger
 

34. Converting long into int: Write a program that converts long into int
 

35. Computing the floor of a division and modulus: Write a program that computes the floor division and the floor modulus of the given dividend (x) and divisor (y)
 

36. Next floating-point value: Write a program that returns the next floating-point adjacent to the given float/double value in the direction of positive and negative infinity
 

37. Multiplying two large int/long values and operation overflow: Write a program that multiplies two large int/long values and throws an arithmetic exception in the case of operation overflow
 

38. Fused Multiply Add (FMA): Write a program that takes three float/double values (a, b, c) and computes a * b + c in an efficient way
 

39. Compact number formatting: Write a program that formats the number 1,000,000 to 1M (US locale) and to 1 mln (Italian locale). In addition, parse 1M and 1 mln from a string into a number
 

Objects Immutability and Switch Expression
==========================================
40 Checking null references in functional style and imperative code: Write a program that performs the null checks on the given references in a functional style and imperative code
 

41. Checking null references and throwing a customized NullPointerException error: Write a program that performs the null checks on the given references and throws NullPointerException with custom messages
 

42. Checking null references and throwing the specified exception (example, IllegalArgumentException): Write a program that performs the null checks on the given references and throws the specified exception
 

43. Checking null references and returning non-null default references: Write a program that performs the null checks on the given reference, and if it is non-null, then return it; otherwise, return a non-null default reference
 

44. Checking the index in the range from 0 to length: Write a program that checks whether the given index is between 0 (inclusive) and the given length (exclusive). If the given index is out of the [0, given length] range, then throw IndexOutOfBoundsException
 

45. Checking the subrange in the range from 0 to length: Write a program that checks whether the given subrange [given start, given end] is within the bounds of the range from [0, given length]. If the given subrange is not in the [0, given length] range, then throw IndexOutOfBoundsException
 

46. equals() and hashCode(): Explain and exemplify how equals() and hashCode() methods work in Java
 

47. Immutable objects in a nutshell: Explain and exemplify what is an immutable object in Java
 

48. Immutable string: Explain why the String class is immutable
 

49. Writing an immutable class: Write a program that represents an immutable class
 

50. Passing/returning mutable objects to/from an immutable class: Write a program that passes and returns a mutable object to/from an immutable class
 

51. Writing an immutable class via the Builder pattern: Write a program that represents an implementation of the Builder pattern in an immutable class
 

52. Avoiding bad data in immutable objects: Write a program that prevents bad data in immutable objects
 

53. Cloning objects: Write a program that exemplifies shallow and deep cloning techniques
 

54. Overriding toString(): Explain and exemplify practices for overriding toString()
 

55. switch expressions: Provide a brief overview of the switch expressions in JDK 12
 

56. Multiple case labels: Write a snippet of code for exemplifying the JDK 12 switch with multiple case labels
 

57. Statement blocks: Write a snippet of code for exemplifying the JDK 12 switch with case labels that point to a curly-braced block
 

Working with Date and Time
==========================
58. Converting a string to date and time: Write a program that exemplifies conversions between a string and date/time
 
59. Formatting date and time: Explain the format pattern for date and time
 

60. Getting the current date/time without time/date: Write a program that extracts the current date without the time or date
 

61. LocalDateTime from LocalDate and LocalTime: Write a program that builds a LocalDateTime from LocalDate object and LocalTime. It combines the date and time in a single LocalDateTime object
 

62. Machine time via an Instant class: Explain and give an example of the Instant API
 

63. Defining a period of time using date-based values (Period) and a duration of time using time-based values (Duration): Explain and give an example of the usage of the Period and Duration APIs
 

64. Getting date and time units: Write a program that extracts the date and time units (for example, extract from date the year, month, minute, and so on) from an object representing a date-time
 

65. Adding and subtracting to/from a date-time: Write a program that adds (and subtracts) an amount of time (for example, years, days, or minutes) to a date-time object (for example, add an hour to date, subtract 2 days from LocalDateTime, and so on)
 

66. Getting all time zones with UTC and GMT: Write a program that displays all the available time zones with UTC and GMT
 

67. Getting the local date-time in all available time zones: Write a program that displays the local time in all the available time zones
 

68. Displaying date-time information about a flight: Write a program that displays information about a scheduled flight time of 15 hours and 30 minutes. More precisely, a flight from Perth, Australia to Bucharest, Europe
 

69. Converting a Unix timestamp to date-time: Write a program that converts a Unix timestamp to java.util.Date and java.time.LocalDateTime
 

70. Finding the first/last day of the month: Write a program that finds the first/last day of the month via JDK 8, TemporalAdjusters
 

71. Defining/extracting zone offsets: Write a program that reveals different techniques for defining and extracting zone offsets
 

72. Converting between Date and Temporal: Write a program that converts between Date and Instant, LocalDate, LocalDateTime, and so on
 

73. Iterating a range of dates: Write a program that iterates a range of given dates, day by day (with a step of a day)
 

74. Calculating age: Write a program that calculates the age of a person
 

75. Start and end of a day: Write a program that returns the start and end time of a day
 

76. Difference between two dates: Write a program that calculates the amount of time, in days, between two dates
 

77. Implementing a chess clock: Write a program that implements a chess clock
 

Arrays Collection and Data Structure
===================================
78. Sorting an array: Write several programs that exemplify different sorting algorithms for arrays. Also, write a program for shuffling arrays
 

79. Finding an element in an array: Write several programs that exemplify how to find the given element (primitive and object) in a given array. Find the index and/or simply check whether the value is in the array
 

80. Checking whether two arrays are equal or mismatches: Write a program that checks whether the two given arrays are equals or whether there is a mismatch
 

81. Comparing two arrays lexicographically: Write a program that compares the given arrays lexicographically
 

82. Creating a stream from an array: Write a program that creates a stream from the given array
 

83. Minimum, maximum, and average of an array: Write a program that computes the maximum, minimum, and average of the given array
 

84. Reversing an array: Write a program that reverses the given array
 

85. Filling and setting an array: Write several examples for filling up an array and setting all elements based on a generator function to compute each element
 

86. Next Greater Element (NGE): Write a program that returns the NGE for each element of an array
 

87. Changing array size: Write a program that adds an element to an array by increasing its size by one. In addition, write a program that increases the size of an array with the given length
 

88. Creating unmodifiable/immutable collections: Write several examples that create unmodifiable and immutable collections
 

89. Mapping a default value: Write a program that gets a value from Map or a default value
 

90. Computing whether absent/present in a Map: Write a program that computes the value of an absent key or a new value of a present key
 
91. Removal from a Map: Write a program that removes from a Map by means of the given key
 
92. Replacing entries from a Map: Write a program that replaces the given entries from a Map
 
93. Comparing two maps: Write a program that compares two maps
 
94. Merging two maps: Write a program that merges two given maps
 
95. Copying HashMap: Write a program that performs a shallow and deep copy of HashMap
 
96. Sorting a Map: Write a program that sorts a Map
 
97. Removing all elements of a collection that match a predicate: Write a program that removes all elements of a collection that match the given predicate
 
98. Converting a collection into an array: Write a program that converts a collection into an array
 
99. Filtering a collection by List: Write several solutions for filtering a collection by a List. Reveal the best way of doing this
 
100. Replacing elements of a List: Write a program that replaces each element of a List with the result of applying a given operator to it
 
101. Thread-safe collections, stacks, and queues: Write several programs that exemplify the usage of Java thread-safe collections
 
102. Breadth-first search (BFS): Write a program that implements the BFS algorithm
 
103. Trie: Write a program that implements a Trie data structure
 
104. Tuple: Write a program that implements a Tuple data structure
 
105. Union Find: Write a program that implements the Union Find algorithm
 
106. Fenwick Tree or Binary Indexed Tree: Write a program that implements the Fenwick Tree algorithm
 
107. Bloom filter: Write a program that implements the Bloom filter algorithm

Java IO, Files, Buffers Scanning and Formatting
=============================================== 
108. Creating file paths: Write several examples of creating several kinds of file paths (for example, absolute paths, relative paths, and so on)
 
109. Converting file paths: Write several examples of converting file paths (for example, converting a file path into a string, URI, file, and so on)
 
110. Joining file paths: Write several examples of joining (combining) file paths. Define a fixed path and append other different paths to it (or replace a part of it with other paths)
 
111. Constructing a path between two locations: Write several examples that construct a relative path between two given paths (from one path to another)
 
112. Comparing file paths: Write several examples of comparing the given file paths
 
113. Walking paths: Write a program that visits all the files within a directory, including subdirectories. Moreover, write a program that searches a file by name, deletes a directory, moves a directory, and copies a directory
 
114. Watching paths: Write several programs that watch changes that occur on a certain path (for example, create, delete, and modify)
 
115. Streaming a file's content: Write a program that streams the content of the given file
 
116. Searching for files/folders in a file tree: Write a program that searches for the given files/folders in the given file tree
 
117. Reading/writing text files efficiently: Write several programs to exemplify different approaches for reading and writing a text file in an efficient manner
 
118. Reading/writing binary files efficiently: Write several programs to exemplify different approaches for reading and writing a binary file in an efficient manner
 
119. Searching in big files: Write a program that efficiently searches the given string in a big file
 
120. Reading a JSON/CSV file as an object: Write a program that reads the given JSON/CSV file as an object (POJO)
 
121. Working with temporary files/folders: Write several programs for working with temporary files/folders
 
122. Filtering files: Write several user-defined filters for files
 
123. Discovering mismatches between two files: Write a program that discovers the mismatches between two files at the byte level
 
124. Circular byte buffer: Write a program that represents an implementation of a circular byte buffer
 
125. Tokenizing files: Write several snippets of code to exemplify different techniques of tokenizing a file content
 
126. Writing formatted output directly to a file: Write a program that formats the given numbers (integers and doubles) and outputs them to a file
 
127. Working with Scanner: Write several snippets of code to reveal Scanner capabilities

Java Reflection, Interface Constructor method and Fields
==========================================================
 
128. Inspecting packages: Write several examples for inspecting Java packages (for example, names, a list of classes, and so on)
 
129. Inspecting classes and superclasses: Write several examples for inspecting classes and superclasses (for example, get Class via the class name, modifiers, implemented interfaces, constructors, methods, and fields)
 
130. Instantiating via a reflected constructor: Write a program that creates instances via reflection
 
131. Getting the annotation of a receiver type: Write a program that gets the annotation on a receiver type
 
132. Getting synthetic and bridge constructs: Write a program that gets synthetic and bridge constructs via reflection
 
133. Checking the variable number of arguments: Write a program that checks whether a method gets a variable number of arguments
 
134. Checking default methods: Write a program that checks whether a method is default
 
135. Nest-based access control via reflection: Write a program that provides access to nest-based constructs via reflection
 
136. Reflection for getters and setters: Write several examples that invoke getters and setters via reflection. Additionally, write a program that generates getters and setters via reflection
 
137. Reflecting annotations: Write several examples of fetching different kinds of annotations via reflection
 
138. Invoking an instance method: Write a program that invokes an instance method via reflection
 
139. Getting static methods: Write a program that groups the static methods of the given class and invokes one of them via reflection
 
140. Getting generic types of methods, fields, and exceptions: Write a program that fetches the generic types of the given methods, fields, and exceptions via reflection
 
141. Getting public and private fields: Write a program that fetches the public and private fields of the given class via reflection
 
142. Working with arrays: Write several examples for working with arrays via reflection
 
143. Inspecting modules: Write several examples for inspecting Java 9 modules via reflection
 
144. Dynamic proxies: Write a program that relies on dynamic proxies for counting the number of invocations of the methods of the given interfaces

Functional Style Programming And Design Pattern
=============================================== 
145. Writing functional interfaces: Write a program to define the road from 0 to a functional interface via a set of meaningful examples
 
146. Lambdas in a nutshell: Explain what a lambda expression is
 
147. Implementing the Execute Around pattern: Write a program that represents an implementation of the Execute Around pattern based on lambdas
 
148. Implementing the Factory pattern: Write a program that represents an implementation of the Factory pattern based on lambdas
 
149. Implementing the Strategy pattern: Write a program that represents an implementation of the Strategy pattern based on lambdas
 
150. Implementing the Template Method pattern: Write a program that represents an implementation of the Template Method pattern based on lambdas
 
151. Implementing the Observer pattern: Write a program that represents an implementation of the Observer pattern based on lambdas
 
152. Implementing the Loan pattern: Write a program that represents an implementation of the Loan pattern based on lambdas
 
153. Implementing the Decorator pattern: Write a program that represents an implementation of the Decorator pattern based on lambdas
 
154. Implementing the Cascaded Builder pattern: Write a program that represents an implementation of the Cascaded Builder pattern based on lambdas
 
155. Implementing the Command pattern: Write a program that represents an implementation of the Command pattern based on lambdas

Functional Style Deep Dive
========================== 
156. Testing high-order functions: Write several unit tests for testing so-called high-order functions
 
157. Testing methods that use lambdas: Write several unit tests for testing methods that use lambdas
 
158. Debugging lambdas: Provide a technique for debugging lambdas
 
159. Filtering the non-zero elements of a stream: Write a stream pipeline that filters the non-zero elements of a stream
 
160. Infinite streams, takeWhile(), and dropWhile(): Write several snippets of code that work with infinite streams. In addition, write several examples of working with the takeWhile() and dropWhile() APIs
 
161. Mapping a stream: Write several examples of mapping a stream via map() and flatMap()
 
162. Finding different elements in a stream: Write a program for finding different elements in a stream
 
163. Matching different elements in a stream: Write a program for matching different elements in a stream
 
164. Sum, max, and min in a stream: Write a program for computing the sum, max, and min of the given stream via primitive specializations of Stream and Stream.reduce()
 
165. Collecting the results of a stream: Write several snippets of code for collecting the results of a stream in a list, map, and set

166. Joining the results of a stream: Write several snippets of code for joining the results of a stream into a String
 
167. Summarization collectors: Write several snippets of code to reveal the usage of summarization collectors
 
168. Grouping: Write snippets of code for working with groupingBy() collectors
 
169. Partitioning: Write several snippets of code for working with partitioningBy() collectors
 
170. Filtering, flattening, and mapping collectors: Write several snippets of code for exemplifying the usage of filtering, flattening, and mapping collectors
 
171. Teeing: Write several examples that merge the results of two collectors (JDK 12 and Collectors.teeing())
 
172. Writing a custom collector: Write a program that represents a custom collector
 
173. Method reference: Write an example of method reference
 
174. Parallel processing of streams: Provide a brief overview of the parallel processing of streams. Provide at least one example each for parallelStream(), parallel(), and spliterator()
 
175. Null-safe streams: Write a program that returns a null-safe stream from an element or a collection of elements
 
176. Composing functions, predicates, and comparators: Write several examples for composing functions, predicates, and comparators
 
177. Default methods: Write an interface that contains a default method

Thread Pools Callables And Synchronizers
======================================== 
178. Thread life cycle states: Write several programs that capture each life cycle state of a thread
 
179. Object- versus class-level locking: Write several examples that exemplify object- versus class-level locking via thread synchronization
 
180. Thread pools in Java: Provide a brief overview of thread pools in Java
 
181. Thread pool with a single thread: Write a program that simulates an assembly line for checking and packing up bulbs using two workers
 
182. Thread pool with a fixed number of threads: Write a program that simulates an assembly line for checking and packing up bulbs using multiple workers
 
183. Cached and scheduled thread pools: Write a program that simulates an assembly line for checking and packing up bulbs using workers as needed (for example, adapt the number of packers (increase or decrease) to ingest the incoming flux produced by the checker)
 
184. Work-stealing thread pool: Write a program that relies on a work-stealing thread pool. More precisely, write a program that simulates an assembly line for checking and packing up bulbs as follows: checking takes place during the day, and packing takes place at night. The checking process results in a queue of 15 million bulbs every day
 
185. Callable and Future: Write a program that simulates an assembly line for checking and packing up bulbs using Callable and Future
 
186. Invoking multiple Callable tasks: Write a program that simulates an assembly line for checking and packing up bulbs as follows: checking takes place during the day, and packing takes place at night. The checking process results in a queue of 100 bulbs every day. The packing process should pack and return all the bulbs at once. In other words, we should submit all Callable tasks and wait for all of them to complete
 
187. Latches: Write a program that relies on CountDownLatch to simulate the process of starting a server. The server is considered started after its internal services have started. Services can be started concurrently and are independent of each other
 
188. Barriers: Write a program that relies on CyclicBarrier to simulate the process of starting a server. The server is considered started after its internal services have started. Services can be prepared for start concurrently (this is time-consuming), but they run interdependently – therefore, once they are ready to start, they must be started all at once
 
189. Exchangers: Write a program that simulates using Exchanger, an assembly line for checking and packing up bulbs using two workers. A worker (the checker) is checking bulbs and adding them in a basket. When the basket is full, the worker gives it to the other worker (the packer) from whom they receive an empty basket. The process repeats until the assembly line stops
 
190. Semaphores: Write a program that simulates using one Semaphore per day at the barbershop. Mainly, our barbershop can serve a maximum of three people at a time (it has only three seats). When a person arrives at the barbershop, they try to take a seat. After they are served by a barber, the person releases the seat. If a person arrives at the barbershop when all three seats are taken, they must wait for a certain amount of time. If this time elapses and no seats have been freed, they will leave the barbershop
 
191. Phasers: Write a program that relies on Phaser to simulate the process of starting a server in three phases. The server is considered started after its five internal services have started. At the first phase, we need to concurrently start three services. At the second phase, we need to concurrently start two more two services (these can be started only if the first three are already running). At phase three, the server performs a final check-in and is considered started

Concurrency Deep Dive 
=====================
192. Interruptible methods: Write a program that exemplifies the best approach for dealing with an interruptible method
 
193. Fork/join framework: Write a program that relies on the fork/join framework to sum the elements of a list. Write a program that relies on the fork/join framework to compute the Fibonacci number at a given position (for example, F12 = 144). In addition, write a program that exemplifies the usage of CountedCompleter
 
194. Fork/join framework and compareAndSetForkJoinTaskTag(): Write a program that applies the fork/join framework to a suite of interdependent tasks that should be executed only once (for example, task D depends on task C and task B, but task C depends on task B as well; therefore, task B must be executed only once, not twice)
 
195. CompletableFuture: Write several snippets of code to exemplify asynchronous code via CompletableFuture
 
196. Combining multiple CompletableFuture objects: Write several snippets of code to exemplify different solutions for combining multiple CompletableFuture objects together
 
197. Optimizing busy waiting: Write a proof of concept to exemplify the optimization of a busy waiting technique via onSpinWait()
 
198. Task cancellation: Write a proof of concept that exemplifies the usage of a volatile variable for holding the cancellation state of a process
 
199. ThreadLocal: Write a proof of concept that exemplifies the usage of ThreadLocal
 
200. Atomic variables: Write a program that counts the integers from 1 to 1,000,000 using a multithreaded application (Runnable)
 
201. ReentrantLock: Write a program that increments the integers from 1 to 1,000,000 using ReentrantLock
 
202. ReentrantReadWriteLock: Write a program that simulates the orchestration of a read-write process via ReentrantReadWriteLock
 
203. StampedLock: Write a program that simulates the orchestration of a read-write process via StampedLock
 
204. Deadlock (dining philosophers): Write a program that reveals and solves the deadlock (circular wait or deadly embrace) that may occur in the famous dining philosophers problem

Optional
========= 
205. Initializing Optional: Write a program that exemplifies the right and wrong approaches for initializing Optional
 
206. Optional.get() and missing value: Write a program that exemplifies the right and wrong usage of Optional.get()
 
207. Returning an already-constructed default value: Write a program that, when no value is present, sets (or returns) an already-constructed default value via the Optional.orElse() method
 
208. Returning a non-existent default value: Write a program that, when no value is present, sets (or returns) a non-existent default value via the Optional.orElseGet() method
 
209. Throwing NoSuchElementException: Write a program that, when no value is present, throws an exception of the NoSuchElementException type or another exception
 
210. The Optional and null references: Write a program that exemplifies the correct usage of Optional.orElse(null)
 
211. Consuming a present Optional class: Write a program that consumes a present Optional class via ifPresent() and via ifPresentElse()
 
212. Returning a present Optional class or another one: Let's assume that we have Optional. Write a program that relies on Optional.or() for returning this Optional (if its value is present) or another Optional class (if its value is not present)
 
213. Chaining lambdas via orElseFoo(): Write a program that exemplifies the usage of orElse() and orElseFoo() for avoiding disrupting lambda chains
 
214. Do not use Optional just for getting a value: Exemplify the bad practice of chaining the Optional methods with the single purpose of getting some values
 
215. Do not use Optional for fields: Exemplify the bad practice of declaring fields of the Optional type
 
216. Do not use Optional in constructor args: Exemplify the bad practice of using Optional in constructors arguments
 
217. Do not use Optional in setters args: Exemplify the bad practice of using Optional in setter arguments
 
218. Do not use Optional in methods args: Exemplify the bad practice of using Optional in method arguments
 
219. Do not use Optional to return empty or null collections or arrays: Exemplify the bad practice of using Optional for returning the empty/null collections or arrays
 
220. Avoiding Optional in collections: Using Optional in collections can be a design smell. Exemplify a typical use case and possible alternatives for avoiding Optional in collections
 
221. Confusing of() with ofNullable(): Exemplify the potential consequences of confusing Optional.of() with ofNullable()
 
222. Optional<T> versus OptionalInt: Exemplify the usage of non-generic OptionalInt instead of Optional<T>
 
223. Asserting equality of Optional classes: Exemplify asserting the equality of Optional classes
 
224. Transforming values via map() and flatMap(): Write several snippets of code for exemplifying the usage of Optional.map() and flatMap()
 
225. Filter values via Optional.filter(): Exemplify the usage of Optional.filter() for rejecting wrapped values based on a predefined rule
 
226. Chaining the Optional and Stream APIs: Exemplify the usage of Optional.stream() for chaining the Optional API with the Stream API
 
227. Optional and identity-sensitive operations: Write a snippet of code that sustains the fact that identity-sensitive operations should be avoided in the case of Optional
 
228. Return  boolean if Optional is empty: Write two snippets of code for exemplifying two solutions for returning boolean if the given Optional class is empty

Http Client and WebSocket
========================== 
229. HTTP/2: Provide a brief overview of the HTTP/2 protocol

230. Triggering an asynchronous GET request: Write a program that uses the HTTP Client API to trigger an asynchronous GET request and display the response code and body
 
231. Setting a proxy: Write a program that uses the HTTP Client API to set up a connection via a proxy
 
232. Setting/getting headers: Write a program that adds additional headers to the request and gets the headers of the response
 
233. Specifying the HTTP method: Write a program that specifies the HTTP method of a request (for example, GET, POST, PUT, and DELETE)
 
234. Setting the request body: Write a program that uses the HTTP Client API to add a body to a request
 
235. Setting connection authentication: Write a program that uses the HTTP Client API to set up a connection authentication via username and password
 
236. Setting a timeout: Write a program that uses the HTTP Client API to set the amount of time we want to wait for a response (timeout)
 
237. Setting the redirect policy: Write a program that uses the HTTP Client API to automatically redirect if needed
 
238. Sending sync and async requests: Write a program that sends the same request in sync and async modes
 
239. Handling cookies: Write a program that uses the HTTP Client API to set a cookie handler
 
240. Getting response information: Write a program that uses the HTTP Client API to get information about the response (for example, URI, version, headers, status code, body, and so on)
 
241. Handling response body types: Write several snippets of code to exemplify how to handle common response body types via HttpResponse.BodyHandlers
 
242. Getting, updating, and saving a JSON: Write a program that uses the HTTP Client API to get, update, and save a JSON
 
243. Compression: Write a program that handles compressed responses (for example, .gzip)
 
244. Handling form data: Write a program that uses the HTTP Client API to submit a data form (application/x-www-form-urlencoded)
 
245. Downloading a resource: Write a program that uses the HTTP Client API to download a resource
 
246. Uploading with multipart: Write a program that uses the HTTP Client API to upload a resource
 
247. HTTP/2 server push: Write a program that exemplifies the HTTP/2 server push feature via the HTTP Client API
 
248. WebSocket: Write a program that opens a connection to a WebSocket endpoint, collects data for 10 seconds, and closes the connection
 
